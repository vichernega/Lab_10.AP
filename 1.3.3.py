# Чернеги Вікторії   Б19_д/122Б
'''
Сформувати функцію для обчислення індексу максимального елемента масиву
n*n, де 1<=n<=5.
'''

import numpy as np                                          #імпортування бібліотек
import random
import time

def max_iter():                                             # функція, що обчислює ітераційно індекси максимального елемента масиву
    start = time.time()                                     # відлік часу
    list, a_index = [], np.array([], dtype = int)           # пусті список та масив для збереження максимальних елементів кожної осі масиву та їх індексів
    for i in range(n):                                      # цикл, для проходження по осям масиву
        for j in range(n):                                  # цикл для проходження по елементам осей в масиві
            k = max(array[np.array(i)])                     # максимальний елемент осі і
            if array[i][j] == k:                            # якщо елемент масиву максимальний, то запам'ятовуємо його індекси
                i1, j1 = i, j
                list.append(k)                              # додавання максимального елемента з осі до списку
                a_index = np.append(a_index, np.array([i1, j1]))    # додавання індексів максимального елемента з даної осі в масив
    for i in range(len(list)):                                      # цикл для проходження по елементам списку list
        if max(list) == list[i]:                            # якщо елемент списку максимальний, то виводяться за формулою елементи з масиву, де зберігаються індекси всіх максимальних елементів
            print(f'Indexes of the maximum element are {a_index[i*2], a_index[i*2+1]}')
    print(f'Time: {time.time() - start} seconds')           # час виконання програми


def max_rec(array):                                         # функція, що обчислює рекурсивно індекси максимального елемента масиву
    if len(array) == 1:                                     # умова для виходу з ітерації
        list1.append(max(array[0]))                         # якщо залишився один елемент у масиві, то додаємо у список його максимальний елемент
        for i in range(len(array)):                         # цикл для проходження по осям масиву
            for j in range(n):                              # цикл для проходження по елементам масиву
                if array[i][j] == max(array[-1]):           # якщо елемент є максимальним на осі, то запам'ятовуємо його індекси і додаємо у список index
                    a, b = i, j
                    index.append(b)
                    index.append(a)
    else:
        list1.append(max(array[-1]))                        # додавання у список максимального елемента(число) з останнього елемента(підмасив) масиву
        for i in range(len(array)):                         # цикл для проходження по осям масиву
            for j in range(n):                              # цикл для проходження по елементам масиву
                if array[i][j] == max(array[-1]):           # якщо елемент є максимальним на осі, то запам'ятовуємо його індекси і додаємо у список index
                    a, b = i, j
                    index.append(b)
                    index.append(a)
        max_rec(array[:-1])                                 # виклик рекурсивної функції для масиву без останнього елемента
        for i in range(len(list1)):                         # цикл для проходження по елементам списку list
            if max(list1) == list1[i]:                      # якщо елемент списку максимальний, то виводяться за формулою елементи з масиву, де зберігаються індекси всіх максимальних елементів
                return (f'Indexes of the maximum element are {index[i * 2 + 1], index[i * 2]}')



n = int(input('Put your number (1<=n<=5): n = '))           # введення розмірності масиву
array = np.zeros((n, n), dtype = int)                       # масив, заповнений нулями типу int
list1, index = [], []                                        # пусті списки для збереження максимальних елементів кожної осі масиву та їх індексів
for i in range(n):                                          # цикл, для заповнення масиву рандомними значеннями
    for j in range(n):
        array[i][j] = random.randint(0, 100)
print(array)                                                # виведення масиву

max_iter()                                                  # виклик функції, що обчислює ітераційно
start = time.time()                                         # відлік часу
print(max_rec(array))                                       # виклик функції, що обчислює рекурсивно
print(f'Time: {time.time() - start} seconds')               # час виконання програми

'''
Перевага рекурсивної функції у швидкості виконання, але ітераційна більш читабельніша та передбачає, що максимальний елемент
може повторюватись і виводить всі позиції, де він розташований.
'''